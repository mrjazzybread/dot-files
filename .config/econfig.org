#+title: Emacs configuration
#+begin_src emacs-lisp :results none
  (load-file "~/.config/sensitive.el")
#+end_src
* Package Configuration
Add MELPA to the list of recognized archives
#+begin_src emacs-lisp :results none
  (require 'package)
  (add-to-list 'package-archives
               '("melpa" . "https://melpa.org/packages/") t)
  (package-initialize)
#+end_src
Installs use-package if I don't have it already and enables verbose
messages
#+begin_src emacs-lisp :results none
  (unless (package-installed-p 'use-package)
  (package-install 'use-package))

  (require 'use-package)
  (setq use-package-verbose t)
#+end_src
Use-package always installs packages
#+begin_src emacs-lisp :results none
  (setq use-package-always-ensure t)
#+end_src
GNU keys to enable downloading packages
#+begin_src emacs-lisp :results none
  (use-package gnu-elpa-keyring-update)
#+end_src
* Appearance

Disable Splash Screen
#+begin_src emacs-lisp :results none
  (setq inhibit-splash-screen t)
#+end_src
Define font style and height
#+begin_src emacs-lisp :results none
  ;All future frames (useful for the daemon)
  (setq default-frame-alist '((font . "Roboto Mono 22")))
  (add-to-list 'default-frame-alist '(background-color . "#34293E"))
  ;The initial frame (useful for the gui)
  (setq initial-frame-alist '((font . "Roboto Mono 22")))
  (add-to-list 'initial-frame-alist '(background-color . "#34293E"))
#+end_src
Set theme (currently Shades of Purple).  My setup is a little weird: I
first set it to ~doom-shades-of-purple~ and then ~shades-of-purple~.  This
ends up with a color scheme that is pleasant for most modes.
#+begin_src emacs-lisp :results none
  (use-package doom-themes)
  (use-package shades-of-purple-theme)
  (setq custom-safe-themes t)
  (load-theme 'doom-shades-of-purple t)
  (load-theme 'shades-of-purple)
#+end_src
Disables a bunch of needless UI noise.
#+begin_src emacs-lisp :results none
  (cond ((> emacs-major-version 20)
         (tool-bar-mode -1) ; introduced in emacs 21
         (menu-bar-mode -1)
         (scroll-bar-mode -1)
         (menu-bar-showhide-fringe-menu-customize-disable)
         (blink-cursor-mode -1)
         (windmove-default-keybindings 'meta)))
#+end_src
Pretty mode line
#+begin_src emacs-lisp :results none
  (use-package doom-modeline)
  (doom-modeline-mode 1)

  (use-package doom-modeline-now-playing)
  (doom-modeline-now-playing-timer)

  (doom-modeline-def-modeline 'main
   '(bar matches buffer-info buffer-position now-playing)
   '(time major-mode))
#+end_src
Display time in mode line
#+begin_src emacs-lisp :results none
  (display-time-mode 1)
#+end_src
Allows me to see the column number as well as the line number.
#+begin_src emacs-lisp :results none
  (column-number-mode)
#+end_src

* ~utf-8~
#+begin_src emacs-lisp :results none
  (prefer-coding-system       'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (setq default-buffer-file-coding-system 'utf-8)
  (set-language-environment 'utf-8)
  (set-selection-coding-system 'utf-8)
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+end_src

* Conveniences
Don't use ui dialogs
#+begin_src emacs-lisp :results none
  (setq use-dialog-box nil)
#+end_src
Suppress annoying message any time you start a new frame
#+begin_src emacs-lisp :results none
  (setq server-client-instructions nil)
#+end_src
Enable ~recentf~ mode to remember recently opened files
#+begin_src emacs-lisp :results none
  (setq recentf-max-saved-items 10000)
  (recentf-mode 1)

  (add-to-list 'recentf-exclude
    	     (lambda (s) (cl-search "/test/" s)))
  (add-to-list 'recentf-exclude
    	     (lambda (s) (cl-search "/tmp/" s)))
  (add-to-list 'recentf-exclude
    	     (lambda (s) (cl-search "/sudo:" s)))
#+end_src
Every time a file is visited, update the list of recently visited
files.
#+begin_src emacs-lisp :results none
  (add-hook 'find-file-hook 'recentf-save-list)
#+end_src
Undo and redo modifications to the window configuration.  Use repeat
mode to easily undo multiple modifications.
#+begin_src emacs-lisp :results none
  (winner-mode)
  (global-set-key "\C-xp" 'winner-undo)
  (global-set-key "\C-xn" 'winner-redo)

  (repeat-mode 1)

  (setq winner-repeat-map
        (let ((map (make-sparse-keymap)))
  	(define-key map (kbd "p") 'winner-undo)
          (define-key map (kbd "n") 'winner-redo)
  	map))
#+end_src
Disable repeat mode in Dired
#+begin_src emacs-lisp :results none
  (setq dired-jump-map nil)
#+end_src
Set scratch buffer major mode to ~org-mode~
#+begin_src emacs-lisp :results none
  (setq initial-major-mode 'org-mode)
  (setq initial-scratch-message "")
#+end_src
Better keybinding to run a shell command
#+begin_src emacs-lisp :results none
  (global-set-key (kbd "M-s s") #'async-shell-command)
#+end_src
When running a shell command, do not display the command buffer until
there is output.
#+begin_src emacs-lisp :results none
  (setq async-shell-command-display-buffer nil)
#+end_src
Minibuffer history persists across multiple sessions
#+begin_src emacs-lisp :results none
  (savehist-mode)
#+end_src
Ensures that backups and auto-saves go to a separate directory instead
of stinking up the working directory.
#+begin_src emacs-lisp :results none
  (defvar backup-dir (expand-file-name "~/.emacs.d/backup/"))
  (defvar autosave-dir (expand-file-name "~/.emacs.d/autosave/"))
  (setq backup-directory-alist (list (cons ".*" backup-dir)))
  (setq auto-save-list-file-prefix autosave-dir)
  (setq auto-save-file-name-transforms `((".*" ,autosave-dir t)))
#+end_src
Package to interface with MPD
#+begin_src emacs-lisp :results none
  (use-package mingus)
#+end_src
Package for using connecting and pairing Bluetooth devices
#+begin_src emacs-lisp :results none
  (use-package bluetooth)
#+end_src
Package for restoring and reading from the trash folder
#+begin_src emacs-lisp :results none
  (use-package trashed)
#+end_src
Package that displays when I am in Emacs on discord
#+begin_src emacs-lisp :results none
  (use-package elcord)
  (setq elcord-display-buffer-details nil)
  (setq elcord-editor-icon "doom_cute_icon")
  (elcord-mode)
#+end_src
Updates the PATH according to the environment in which Emacs is running
#+begin_src emacs-lisp :results none
  (use-package exec-path-from-shell)
  (when (daemonp)
    (exec-path-from-shell-initialize))
#+end_src

** Buffer Navigation
Function for jumping to another part of the buffer quickly
#+begin_src emacs-lisp :results none
  (use-package avy)
  (setq avy-timeout-seconds 0.3)
  (bind-key "M-j" 'avy-goto-char-timer)
#+end_src
Keybindings for navigating functions
#+begin_src emacs-lisp :results none
  (bind-key "C-M-p" #'beginning-of-defun)
  (bind-key "C-M-n" #'end-of-defun)
#+end_src
Opens files at the last visited location
#+begin_src emacs-lisp :results none
  (save-place-mode 1)
#+end_src
Key binding for returning to the beginning of the line ignores
indentation
#+begin_src emacs-lisp :results none
  (global-set-key (kbd "C-a") #'back-to-indentation)
#+end_src
Shows an indexed view of the current buffer and allows for
straightforward navigation
#+begin_src emacs-lisp :results none
  (use-package consult)
  (defun consult-org-maybe ()
    (interactive)
    (if (eq major-mode 'org-mode)
        (consult-org-heading)
      (consult-imenu)))

  (global-set-key (kbd "M-g i") #'consult-org-maybe)
#+end_src
Faster scroll
#+begin_src emacs-lisp :results none
  (when (display-graphic-p)
    (setq mouse-wheel-scroll-amount '(2 ((shift) . 1))
          mouse-wheel-progressive-speed nil))
#+end_src

** Editing Buffers
Enable creation of pairs of brackets or quotes when one is inserted.
#+begin_src emacs-lisp :results none
  (setq skeleton-pair t)
  (bind-key "(" 'skeleton-pair-insert-maybe)
  (bind-key "{" 'skeleton-pair-insert-maybe)
  (bind-key "[" 'skeleton-pair-insert-maybe)
  (bind-key (char-to-string 34) 'skeleton-pair-insert-maybe)
  ;char 34 is the single quote, putting the character itself
  ;ruins prettify symbols mode
#+end_src
Enable Emacs to track changes made to files by different programs.
#+begin_src emacs-lisp :results none
  (setq auto-revert-interval 1)
  (global-auto-revert-mode 1)
#+end_src
Delete trailing white spaces after saving a file.
#+begin_src emacs-lisp :results none
  (add-hook 'before-save-hook
            'delete-trailing-whitespace)
#+end_src
Multiple cursors
#+begin_src emacs-lisp :results none
  (use-package multiple-cursors)
  (global-set-key (kbd "C->") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
  (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)
  (global-set-key (kbd "C-x x SPC") 'set-rectangular-region-anchor)
#+end_src
Yanking a string replaces the current selection
#+begin_src emacs-lisp :results none
  (delete-selection-mode 1)
#+end_src
Command to insert the current file name
#+begin_src emacs-lisp :results none
  (global-set-key (kbd "C-c w")
  		(lambda () (interactive)
  		  (insert (buffer-file-name
  			   (window-buffer (minibuffer-selected-window))))))
#+end_src
Command to consult and insert from kill-ring
#+begin_src emacs-lisp :results none
  (global-set-key (kbd "C-c y") #'consult-yank-from-kill-ring)
  (global-set-key (kbd "C-x C-SPC") #'consult-mark)
#+end_src

* Popup windows
This makes it so every pop up window appears in the current window.
Special rule for "magit-diff" to prevent it from taking up the entire
window when committing.
#+begin_src emacs-lisp :results none
  (add-to-list 'display-buffer-alist
                 '(""
                   (display-buffer-same-window)))

  (add-to-list 'display-buffer-alist
               '("magit-diff"
                 (display-buffer-no-window)))

  (add-to-list 'display-buffer-alist
  	     '((derived-mode
  		coq-response-mode coq-goals-mode mu4e-view-mode)
  	       (display-buffer-no-window)))
#+end_src

* GPG
#+begin_src emacs-lisp :results none
  ;; let's get encryption established
  (use-package pinentry)
  (setenv "GPG_AGENT_INFO" nil)  ;; use emacs pinentry
  (setq auth-source-debug t)

  (setq epg-gpg-program "gpg2")  ;; not necessary
  (require 'epa-file)
  (epa-file-enable)
  (setq epa-pinentry-mode 'loopback)
  (setq epg-pinentry-mode 'loopback)
  (pinentry-start)

  (require 'org-crypt)
  (org-crypt-use-before-save-magic)

  (setq epa-file-encrypt-to email1)
  (setq epa-file-select-keys 1)
#+end_src

* Coding Packages
** ~Flymake~
Package used by Eglot for highlighting errors
#+begin_src emacs-lisp :results none
  (use-package flymake)
  (add-hook 'prog-mode-hook #'flymake-mode)
  (keymap-set flymake-mode-map "C-c C-x" #'flymake-goto-next-error)
#+end_src

** Corfu
Package for completion suggestions
#+begin_src emacs-lisp :results none
  (use-package corfu)
  (setq corfu-auto t)

  (global-corfu-mode 1)

  (use-package nerd-icons-corfu)
  (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter)
#+end_src

** OCaml packages
Dune is bad and stupid and so I use a custom build command that goes
to the root of the project and then calls dune.
#+begin_src emacs-lisp :results none
  (defun ocaml-compile ()
    (setq compile-command "~/.config/ocompile.sh"))

  (use-package tuareg)
  (add-hook 'tuareg-mode-hook #'ocaml-compile)
#+end_src
Format OCaml code after saving the buffer
#+begin_src emacs-lisp :results none
  (use-package ocamlformat)
  (setq ocamlformat-enable 'enable-outside-detected-project)
  (setq ocamlformat-show-errors nil)
  (add-hook 'before-save-hook #'ocamlformat-before-save)
#+end_src
Dune package
#+begin_src emacs-lisp :results none
  (use-package dune)
#+end_src

** Rust packages
#+begin_src emacs-lisp :results none
  (use-package rustic)
  (setq rustic-lsp-client #'eglot)
#+end_src

** ~Eglot~
Prevent ~Eglot~ from being using when writing Rocq.
#+begin_src emacs-lisp :results none
  (defun lsp-no-coq ()
    (interactive)
    (unless (eq major-mode 'coq-mode) (eglot-ensure)))

  (use-package eglot)
  (add-hook 'prog-mode-hook #'lsp-no-coq)
#+end_src
Eldoc popup.  Useful for displaying documentation and errors.  I have
it set to a keybinding and not a timer since I prefer to control what
pop ups appear.
#+begin_src emacs-lisp :results none
  (use-package eldoc-box)
  (setq eldoc-box-only-multi-line t)
  (bind-key "\C-hj" #'eldoc-box-help-at-point)
#+end_src

** Git packages

Folks... It's ~Magit~.
#+begin_src emacs-lisp :results none
  (use-package magit)

  (keymap-set magit-mode-map "C-c C-p" #'magit-section-up)

  (setq magit-display-buffer-function
        #'magit-display-buffer-traditional)

  (setq magit-bury-buffer-function
        'magit-restore-window-configuration)

  (bind-key "C-x g" #'magit-status)
#+end_src

** Yaml
Not a lot to be said here
#+begin_src emacs-lisp :results none
  (use-package yaml-mode)
#+end_src

* ~Dired~
Deleted files are moved to the trash folder
#+begin_src emacs-lisp :results none
  (setq delete-by-moving-to-trash t)
#+end_src
Start ~Dired~ in omit mode
#+begin_src emacs-lisp :results none
  (add-hook 'dired-mode-hook #'dired-omit-mode)
#+end_src
Bind the "o" key to show hidden files
#+begin_src emacs-lisp :results none
  (add-hook 'dired-mode-hook
            (lambda () (local-set-key
                        (kbd "o") #'dired-omit-mode)))
#+end_src
Bind the "b" key to move up in the directory
#+begin_src emacs-lisp :results none
  (add-hook 'dired-mode-hook
            (lambda () (local-set-key
                        (kbd "b") #'dired-up-directory)))
#+end_src
Set files to omit
#+begin_src emacs-lisp :results none
  (setq dired-omit-files
        (rx (or (seq bol (? ".") "#")     ;; emacs autosave files
                (seq bol ".") ;; dot-files
                (seq "~" eol)                 ;; backup-files
                (seq bol "CVS" eol)           ;; CVS dirs
  	      (seq bol "CVS" eol)           ;; CVS dirs
                ))
        )
  (setq dired-omit-files
        (concat dired-omit-files "\\|\\.gpg$")) ;; encrypted files
#+end_src
Make it so ~Dired~ buffers are just a list of file names.
#+begin_src emacs-lisp :results none
  (add-hook 'dired-mode-hook
            (lambda () (dired-hide-details-mode 1)))
#+end_src
Icons for ~Dired~ mode.
#+begin_src emacs-lisp :results none
   ;This package requires additional fonts
  (use-package all-the-icons-dired
    :hook (dired-mode . all-the-icons-dired-mode))
#+end_src
Kill ~Dired~ buffer when opening a new ~Dired~ buffer.
#+begin_src emacs-lisp :results none
  (setq dired-kill-when-opening-new-dired-buffer t)
#+end_src
Dired buffers update when there is a change in one of the files in the
directory
#+begin_src emacs-lisp :results none
  (setq global-auto-revert-non-file-buffers t)
#+end_src
Keeps track of visited ~Dired~ buffers
#+begin_src emacs-lisp :results none
  (use-package dired-hist)
  (define-key dired-mode-map "l" #'dired-hist-go-back)
  (define-key dired-mode-map "r" #'dired-hist-go-forward)
  (dired-hist-mode 1)
#+end_src
More convenient way to search through sub-directories.
#+begin_src emacs-lisp :results none
  (use-package dired-subtree)
  (keymap-set dired-mode-map "i" #'dired-subtree-insert)
  (keymap-set dired-mode-map "DEL" #'dired-subtree-remove)
#+end_src
Disable "Omit N files" message
#+begin_src emacs-lisp :results none
  (setq dired-omit-verbose nil)
#+end_src
Quickly browse files in read only mode
#+begin_src emacs-lisp :results none
  (defun view-browse (f)

    (let ((b (current-buffer)))
      (dired-jump)
      (condition-case nil
  	((lambda () (funcall f)
  	   (dired-find-file)
  	   (kill-buffer b)
  	   (view-mode)))
        (error
         (progn (switch-to-buffer b)
  	      (message "No more files in current directory"))))))

  (defun view-next-file ()
    (interactive)
    (view-browse (lambda () (dired-next-line 1))))

  (defun view-previous-file ()
    (interactive)
    (view-browse (lambda () (dired-previous-line 1)))
    )

  (define-key view-mode-map (kbd "n") 'view-next-file)
  (define-key view-mode-map (kbd "p") 'view-previous-file)
#+end_src
Change ~ls~ switches to use human readable file sizes and to list
directories first.
#+begin_src emacs-lisp :results none
  (setq dired-listing-switches "-alh --group-directories-first")
#+end_src
When copying a file, have it so if there is another dired buffer open in
another window in the same frame, it selects that buffer by default
#+begin_src emacs-lisp :results none
  (setq dired-dwim-target t)
#+end_src

* Email

Use mu4e to manage emails.  Naturally, requires mu4e to already be
installed.
#+begin_src emacs-lisp :results none
  (require 'mu4e)
#+end_src
Fancy dashboard for mu4e.  Requires local file
#+begin_src emacs-lisp :results none
  (use-package async)
  (load "~/.mu4e-dashboard/mu4e-dashboard.el")
#+end_src
This is necessary so that mu4e won't print an annoying error message
#+begin_src emacs-lisp :results none
  (setq user-mail-address email1)
#+end_src
Function to use for sending emails.
#+begin_src emacs-lisp :results none
  (setq message-send-mail-function 'smtpmail-send-it)
#+end_src
Quitting mu4e returns to the dashboard
#+begin_src emacs-lisp :results none
  (keymap-set mu4e-headers-mode-map "q" #'mu4e-dashboard)
#+end_src
Avoids mail syncing issues
#+begin_src emacs-lisp :results none
  (setq mu4e-change-filenames-when-moving t)
  (setq mu4e-context-policy "pick-first")
#+end_src
Refreshes email every minute
#+begin_src emacs-lisp :results none
  (setq mu4e-update-interval 60)
  (setq mu4e-get-mail-command "mbsync -a")
#+end_src
Set mail directory
#+begin_src emacs-lisp :results none
  (setq mu4e-maildir "~/mail")
#+end_src
Creates two contexts for my two work emails.
#+begin_src emacs-lisp :results none
  (setq mu4e-contexts
        (list
         ;; Work account
         (make-mu4e-context
          :name "FCT"
          :match-func
          (lambda (msg)
            (when msg
              (string-prefix-p "/gmail" (mu4e-message-field msg :maildir))))
          :vars `((user-mail-address . ,email1)
                  (user-full-name    . "Tiago Soares")
      		(smtpmail-smtp-server . "smtp.gmail.com")
      		(smtpmail-smtp-service . 465)
      		(smtpmail-stream-type . ssl)
                  (mu4e-drafts-folder  . "/gmail/[Gmail]/Drafts")
                  (mu4e-sent-folder  . "/gmail/[Gmail]/Sent Mail")
                  (mu4e-refile-folder  . "/gmail/[Gmail]/All Mail")
                  (mu4e-trash-folder  . "/gmail/[Gmail]/Trash")))
         (make-mu4e-context
          :name "Inria"
          :match-func
          (lambda (msg)
            (when msg
              (string-prefix-p "/inria" (mu4e-message-field msg :maildir))))
          :vars `((user-mail-address . ,email2)
                  (user-full-name    . "Tiago Soares")
      		(smtpmail-smtp-server . "smtp.inria.fr")
      		(smtpmail-smtp-service . 587)
      		(smtpmail-stream-type . nil)
                  (mu4e-drafts-folder  . "/inria/Drafts")
                  (mu4e-sent-folder  . "/inria/Sent")
                  (mu4e-trash-folder  . "/inria/Trash")))

         )
        )
#+end_src
Notifications for mu4e
#+begin_src emacs-lisp :results none
  (use-package mu4e-alert)
  (setq mu4e-alert-style 'libnotify)
  (mu4e-alert-enable-notifications)
#+end_src
Human readable header fields
#+begin_src emacs-lisp :results none
  (setq mu4e-headers-fields '((:human-date . 12) (:from . 22) (:subject)))
#+end_src
Better reading and writing experience for emails
#+begin_src emacs-lisp :results none
  (add-hook 'mu4e-view-mode-hook #'writeroom-mode)
  (add-hook 'mu4e-headers-mode-hook #'writeroom-mode)
  (add-hook 'message-mode-hook #'auto-fill-mode)
#+end_src
Suppress annoying "Indexing... message"
#+begin_src emacs-lisp :results none
  (setq mu4e-hide-index-messages t)
#+end_src
Start mu4e
#+begin_src emacs-lisp :results none
  (mu4e)
#+end_src

* Org

#+begin_src emacs-lisp :results none
  (use-package org)
#+end_src

** Some Basic Bookkeeping

Some helpful variables
#+begin_src emacs-lisp :results none
  (defun org-directory (file)
    (concat "~/roam/daily/personal/" file))

  (defvar todo-file
    (org-directory "todo.org.gpg"))

  (defvar agenda-file
    (org-directory "appoint.org.gpg"))
#+end_src
My agenda files:

#+begin_src emacs-lisp :results none
  (setq org-agenda-file-regexp "\\`[^.].*\\.org\\\(\\.gpg\\\)?\\'")
  (setq org-agenda-files (list todo-file agenda-file))
#+end_src
Settings for exporting Org files with citations to TeX.
#+begin_src emacs-lisp :results none
  (setq org-cite-export-processors '((t biblatex "numeric" "numeric")))
  (setq org-cite-global-bibliography '("~/.dot-files/latex/english.bib"))
  (setq org-export-with-sub-superscripts nil)
#+end_src
Restore the window configuration when quitting the agenda view
#+begin_src emacs-lisp :results none
 (setq org-agenda-restore-windows-after-quit t)
#+end_src
Enable notifications for Org agenda items
#+begin_src emacs-lisp :results none
  (use-package org-alert)
  (setq alert-default-style 'libnotify)
  (setq org-alert-interval 300)
  (setq org-alert-notify-cutoff 10)
  (setq org-alert-notify-after-event-cutoff 0)

  (org-alert-enable)
#+end_src
Add menu item to list only items with a ~TODO~ keyword.
#+begin_src emacs-lisp :results none
  (setq org-agenda-custom-commands
        '(("t" "List all items with the TODO keyword" ((todo "TODO")))))
#+end_src
This is very important
#+begin_src emacs-lisp :results none
  (defun what ()
    (interactive)
    (insert "üëÅÔ∏èüëÑüëÅÔ∏è")
    )
#+end_src

** Appearance
Hide emphasis markers and macro braces

#+begin_src emacs-lisp :results none
  (setq org-hide-emphasis-markers t)
  (setq org-hide-macro-markers t)
#+end_src
Make it there is only one star visible in each heading.

#+begin_src emacs-lisp :results none
  (setq org-hide-leading-stars t)
#+end_src
Use LaTeX like syntax to insert special symbols

#+begin_src emacs-lisp :results none
  (setq org-pretty-entities t)
#+end_src
Start Org files with each heading folded.

#+begin_src emacs-lisp :results none
  (setq org-startup-folded t)
#+end_src
Enable Org indentation

#+begin_src emacs-lisp :results none
  (setq org-startup-indented t)
#+end_src
Centre Org agenda
#+begin_src emacs-lisp :results none
  (add-hook 'org-agenda-mode-hook #'writeroom-mode)
#+end_src
Don't show items that are marked as done.
#+begin_src emacs-lisp :results none
  (setq org-agenda-skip-timestamp-if-done t
        org-agenda-skip-deadline-if-done t
        org-agenda-skip-scheduled-if-done t
        org-agenda-skip-scheduled-if-deadline-is-shown t
        org-agenda-skip-timestamp-if-deadline-is-shown t)
#+end_src
Automatic latex preview in Org mode
#+begin_src emacs-lisp :results none
  (setq org-startup-with-latex-preview t)
#+end_src
Package for editing latex snippets in Org-mode.
#+begin_src emacs-lisp :results none
  (use-package org-fragtog)
  (add-hook 'org-mode-hook #'org-fragtog-mode)
#+end_src
Scale up latex preview in Org mode
#+begin_src emacs-lisp :results none
  (setq org-format-latex-options
        (plist-put org-format-latex-options :scale 3))
#+end_src
Org agenda takes up the full window
#+begin_src emacs-lisp :results none
  (setq org-agenda-window-setup 'only-window)
#+end_src
Org agenda does not display the files in which items are written in.
#+begin_src emacs-lisp :results none
  (setq org-agenda-prefix-format
        '((agenda . "%?-12t% s")
  	(todo . "%-12:c") (tags . "%-12:c")
  	(search . "%-12:c")))
#+end_src

*** Org Pretty Symbols

Function for adding pretty symbols for Org mode. Most of these are
just so that Org mode environments aren't awful to look at.
#+begin_src emacs-lisp :results none
    ;; Pretty Symbols for Org
  (defun add-symbols ()
    (push '("#+end_example" . ? ) prettify-symbols-alist)
    (push '("#+end_src" . ? ) prettify-symbols-alist)
    (push '("#+begin_example coq" . ?üêì) prettify-symbols-alist)
    (push '("#+begin_example ocaml" . ?üê´) prettify-symbols-alist)
    (push '("#+begin_src ocaml" . ?üê´) prettify-symbols-alist)
    (push '("#+begin_example ocaml :why3" . ?‚ùî) prettify-symbols-alist)
    ;;errrrrrm, what the ...
    (push '("#+begin_src emacs-lisp :results none" . ?üóø) prettify-symbols-alist)
    (push '("#+ATTR_LATEX: :environment cfml" . ? ) prettify-symbols-alist)
    (push '("#+ATTR_LATEX: :environment ocamlenv" . ? ) prettify-symbols-alist)
    (push '("#+ATTR_LATEX: :environment gospel" . ? ) prettify-symbols-alist)
    (push '("#+ATTR_LATEX: :environment whylang" . ? ) prettify-symbols-alist)
    (push '("->" . ?‚Üí) prettify-symbols-alist)
    (push '("<->" . ?‚Üî) prettify-symbols-alist)
    (push '("|-" . ?‚ä¢) prettify-symbols-alist)
    (push '("/\\" . ?‚àß) prettify-symbols-alist)
    (push '("\\/" . ?‚à®) prettify-symbols-alist)
    (push '("<-" . ?‚Üê) prettify-symbols-alist)
    (prettify-symbols-mode 1))

  (add-hook 'org-mode-hook #'add-symbols)
#+end_src

** Org capture templates

#+begin_src emacs-lisp :results none
  (setq org-capture-templates
        '(
          ("w" "Writing TODO"
           entry (file+headline todo-file "Writing")
           "* TODO %?\n "
           :empty-lines 0)

          ("p" "Phd TODO"
           entry (file+headline todo-file "PhD Tasks")
           "* TODO [[%L][%?]]\n "
           :empty-lines 0)

          ("a" "Appointment"
           entry (file+headline agenda-file "Appointments")
           "* APPOINTMENT %?\n "
           :empty-lines 0)

          ("?" "Question"
           entry (file+headline todo-file "Questions")
           "* üëÅÔ∏èüëÑüëÅÔ∏è [[%L][%?]]\n "
           :empty-lines 0)

          ("r" "Reading"
           checkitem (file+headline todo-file "Reading List")
           "[ ] %?\n")
        ))
#+end_src

** Org Keywords
#+begin_src emacs-lisp :results none
(setq org-todo-keywords
      '((sequence "APPOINTMENT(p)" "SPEC(s)" "TODO(t)" "IN-PROGRESS(i@/!)" "VERIFYING(v!)" "BLOCKED(b@)" "üëÅÔ∏èüëÑüëÅÔ∏è(q)" "|" "DONE(d!)" "OBE(o@!)" "WONT-DO(w@/!)" )
        ))
;; TODO colors
(setq org-todo-keyword-faces
      '(
        ("TODO" . (:foreground "GoldenRod" :weight bold))
        ("APPOINTMENT" . (:foreground "DeepPink" :weight bold))
        ("IN-PROGRESS" . (:foreground "Cyan" :weight bold))
        ("VERIFYING" . (:foreground "DarkOrange" :weight bold))
        ("BLOCKED" . (:foreground "Red" :weight bold))
        ("DONE" . (:foreground "LimeGreen" :weight bold))
        ("WONT-DO" . (:foreground "Firebrick" :weight bold))
        ("SPEC" . (:foreground "LightCyan" :weight bold))
        ))
#+end_src

** Inserting Org Example Blocks

Function for wrapping text around a block
#+begin_src emacs-lisp :results none
  (defun tag-word-or-region (text-begin text-end)
  "Surround current word or region with given text."
  (interactive "sStart tag: \nsEnd tag: ")
  (let (pos1 pos2 bds)
    (if (and transient-mark-mode mark-active)
        (progn
          (goto-char (region-end))
          (insert text-end)
          (goto-char (region-beginning))
          (insert text-begin))
      (progn
        (setq bds (point))
        (goto-char bds)
        (insert text-end)
        (goto-char bds)
        (insert text-begin)))))
#+end_src
Associative list that maps environment names to programming languages
#+begin_src emacs-lisp :results none
  (setq env-map '( ("cfml" . "coq")
    ("ocamlenv" . "ocaml")
    ("gospel" . "ocaml")
    ("whylang" . "ocaml :why3")
  ))
#+end_src
Function to wrap text around an example block

#+begin_src emacs-lisp :results none
  (defun org-insert-code-env (env-name)
    (interactive "sEnvironment name: ")
    (if (equal env-name "elisp")
        (tag-word-or-region
         "#+begin_src emacs-lisp :results none\n"
         "\n#+end_src"
         )
      (tag-word-or-region
       (concat "#+ATTR_LATEX: :environment " env-name
                                "\n#+begin_example " (alist-get env-name env-map nil nil #'equal) "\n")
                        "\n#+end_example"
                        )))
#+end_src
Function to insert a macro
#+begin_src emacs-lisp :results none
  (defun org-insert-macro ()
    (interactive)
    (tag-word-or-region "{{{" "}}}") )
#+end_src

** Remove Spell Checking in Code Blocks
#+begin_src emacs-lisp :results none
  (add-to-list 'ispell-skip-region-alist '("^#\\+BEGIN_SRC" . "#\\+END_SRC"))
  (add-to-list 'ispell-skip-region-alist '("^#\\+BEGIN_EXAMPLE" . "#\\+END_EXAMPLE"))
  (add-to-list 'ispell-skip-region-alist '("^#\\+begin_src" . "#\\+end_src"))
  (add-to-list 'ispell-skip-region-alist '("^#\\+begin_example" . "#\\+end_example"))
  (add-to-list 'ispell-skip-region-alist '("^#\\+" . "\n"))
  (add-to-list 'ispell-skip-region-alist '("~" . "~"))
  (add-to-list 'ispell-skip-region-alist '("/" . "/"))
  (add-to-list 'ispell-skip-region-alist '("{{{" . "}}}"))
  (add-to-list 'ispell-skip-region-alist '("<<" . ">>"))
#+end_src

** Org Key Bindings and Hooks

Global key bindings to access and update the agenda.
#+begin_src emacs-lisp :results none
  (global-set-key "\C-ca" 'org-agenda)
  (global-set-key "\C-cc" 'org-capture)
#+end_src

Keybindings to navigate agenda view
#+begin_src emacs-lisp :results none
  (keymap-set org-agenda-keymap "n" #'org-agenda-next-item)
  (keymap-set org-agenda-keymap "p" #'org-agenda-previous-item)
#+end_src

Keybindings to insert code environments
#+begin_src emacs-lisp :results none
  (keymap-set org-mode-map "C-c C-x C-x" #'org-insert-code-env)
  (keymap-set org-mode-map "C-c C-x C-m" #'org-insert-macro)
#+end_src

** French Notes

Function for inserting a conjugation table for french verbs
#+begin_src emacs-lisp :results none
  (setq conjugation-table
  "|-----------+---|
  | Je        |   |
  |-----------+---|
  | Tu        |   |
  |-----------+---|
  | Il/Elle   |   |
  |-----------+---|
  | Nous      |   |
  |-----------+---|
  | Vous      |   |
  |-----------+---|
  | Ils/Elles |   |
  |-----------+---|")

  (defun start-conjugation ()
    (interactive)
    (insert conjugation-table)
    (org-backward-paragraph)
    (org-cycle)
    (org-cycle))
#+end_src

** LaTeX export
Add common scientific paper classes.

#+begin_src emacs-lisp :results none
  (with-eval-after-load 'ox-latex
    (add-to-list 'org-latex-classes
                 '("llncs"
                   "\\documentclass{llncs}"
                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}"))))

  (with-eval-after-load 'ox-latex
    (add-to-list 'org-latex-classes
                 '("IEEEtran"
                   "\\documentclass{IEEEtran}"
                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}"))))
#+end_src

Disable exporting with table of contents.
#+begin_src emacs-lisp :results none
  (setq org-export-with-toc nil)
#+end_src

** Org Roam

#+begin_src emacs-lisp :results none
  (use-package org-roam)
  (setq org-roam-directory (file-truename "~/roam"))
  (setq org-roam-file-exclude-regexp '("data/" "daily/"))
  (setq org-roam-completion-everywhere t)

  (keymap-global-set "C-c n l" #'org-roam-buffer-toggle)
  (keymap-global-set "C-c n f" #'org-roam-node-find)
  (keymap-global-set "C-c n g" #'org-roam-graph)
  (keymap-global-set "C-c n i" #'org-roam-node-insert)
  (keymap-global-set "C-c n c" #'org-roam-capture)
  (keymap-global-set "C-c n j" #'org-roam-dailies-capture-today)

  (org-roam-db-autosync-mode)
#+end_src
Capture templates for org roam.
#+begin_src emacs-lisp :results none
  (setq org-roam-capture-templates
        '(("t" "travel" plain
           "%?"
           :if-new (file+head "travel/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
           :unnarrowed t)
  	("r" "Reading note" plain
  	 (file "~/roam/templates/reading_template.org")
  	 :if-new (file+head "research/%<%Y%m%d%H%M%S>-${slug}.org.gpg" "#+title: ${title}\n")
  	 :unnarrowed t)
  	("p" "PhD Note" plain
           "%?"
           :if-new (file+head "research/%<%Y%m%d%H%M%S>-${slug}.org.gpg" "#+title: ${title}\n")
           :unnarrowed t
  	 :jump-to-captured t)
  	))
#+end_src
Capture template for org roam dailies
#+begin_src emacs-lisp :results none
  (setq org-roam-dailies-capture-templates
        '(("d" "default" plain "* %?" :target (file+head "%<%Y-%m-%d>.org.gpg" "#+title: %<%Y-%m-%d>
  ") :jump-to-captured t)))
#+end_src

* PDFs
Opens the current file in ~zathura~ and kills the Doc View buffer.
#+begin_src emacs-lisp :results none
  (defun zathura ()
    (when (equal (file-name-extension (buffer-file-name)) "pdf")
    (start-process "zathura" nil "zathura" (buffer-file-name))
    (let ((b (current-buffer)))
      (add-to-list 'recentf-list (buffer-file-name))
      (recentf-save-list)
      (previous-buffer)
      (kill-buffer b)
    )))
#+end_src
When we open a PDF in Emacs, open it in ~zathura~ instead.
#+begin_src emacs-lisp :results none
  (add-hook 'doc-view-mode-hook #'zathura)
#+end_src
Function to run a latex process in the background.
#+begin_src emacs-lisp :results none
  (defun run-latex ()
    (interactive)
    (async-shell-command
     "latexmk -pdf  -pdflatex='pdflatex -interaction=nonstopmode' -pvc --synctex=1 -use-make main.tex"
     "LaTeX"))
#+end_src

* Proof General
Package for working with Rocq
#+begin_src emacs-lisp :results none
  (use-package proof-general)
#+end_src
Removes the EXTREMELY annoying proof general splash screen
#+begin_src emacs-lisp :results none
  (setq proof-splash-enable nil)
#+end_src
When starting a proof, splits windows so that the goals window is
larger than the response window
#+begin_src emacs-lisp :results none
  (setq proof-three-window-mode-policy 'hybrid)
#+end_src
Weird arrow :/
#+begin_src emacs-lisp :results none
  (setq overlay-arrow-string "")
#+end_src
Function to generate a ~Rocq~ Makefile
#+begin_src emacs-lisp :results none
  (defun coq-makefile-gen ()
    (interactive)
    (async-shell-command "coq_makefile -f _CoqProject -o Makefile"))
#+end_src
Why3 configuration
#+begin_src emacs-lisp :results none
  (setq opam-share
        (if (boundp 'opam-share) opam-share
  	(ignore-errors (car (process-lines "opam" "var" "share")))))

  (setq why3-share
        (if (boundp 'why3-share) why3-share
    	(ignore-errors (car (process-lines "why3" "--print-datadir")))))
  (setq why3el
        (let ((f (expand-file-name "emacs/why3.elc" why3-share)))
    	(if (file-readable-p f) f
    	  (when (and opam-share (file-directory-p opam-share))
              (let ((f (expand-file-name "emacs/site-lisp/why3.elc" opam-share)))
                (if (file-readable-p f) f nil))))))
  (when why3el (require 'why3 why3el))
#+end_src

** Unicode Symbols for Iris
#+begin_src emacs-lisp :results none
  ;; Input of unicode symbols
  (use-package math-symbol-lists)
  					; Automatically use math input method for Coq files
  (add-hook 'coq-mode-hook (lambda () (set-input-method "math")))
  (add-hook 'tuareg-mode-hook (lambda () (set-input-method "math")))
  					; Input method for the minibuffer
  ;; (defun my-inherit-input-method ()
  ;;   "Inherit input method from `minibuffer-selected-window'."
  ;;   (let* ((win (minibuffer-selected-window))
  ;;          (buf (and win (window-buffer win))))
  ;;     (when buf
  ;;       (activate-input-method (buffer-local-value 'current-input-method buf)))))
  ;; (add-hook '
  ;; minibuffer-setup-hook #'my-inherit-input-method)

  					; Define the actual input method
  (quail-define-package "math" "UTF-8" "Œ©" t)
  (quail-define-rules ; add whatever extra rules you want to define here...
   ("\\fun"    ?Œª)
   ("\\mult"   ?‚ãÖ)
   ("\\ent"    ?‚ä¢)
   ("\\valid"  ?‚úì)
   ("\\diamond" ?‚óá)
   ("\\box"    ?‚ñ°)
   ("\\bbox"   ?‚ñ†)
   ("\\later"  ?‚ñ∑)
   ("\\pred"   ?œÜ)
   ("\\and"    ?‚àß)
   ("\\or"     ?‚à®)
   ("\\comp"   ?‚àò)
   ("\\ccomp"  ?‚óé)
   ("\\all"    ?‚àÄ)
   ("\\ex"     ?‚àÉ)
   ("\\to"     ?‚Üí)
   ("\\sep"    ?‚àó)
   ("\\lc"     ?‚åú)
   ("\\rc"     ?‚åù)
   ("\\Lc"     ?‚é°)
   ("\\Rc"     ?‚é§)
   ("\\lam"    ?Œª)
   ("\\empty"  ?‚àÖ)
   ("\\Lam"    ?Œõ)
   ("\\Sig"    ?Œ£)
   ("\\-"      ?‚àñ)
   ("\\aa"     ?‚óè)
   ("\\af"     ?‚óØ)
   ("\\auth"   ?‚óè)
   ("\\frag"   ?‚óØ)
   ("\\iff"    ?‚Üî)
   ("\\gname"  ?Œ≥)
   ("\\incl"   ?‚âº)
   ("\\latert" ?‚ñ∂)
   ("\\update" ?‚áù)
   ("\\nin" ?‚àâ)
   ("\\u" ?‚à™)
   ("\\points" ?‚Ü¶)

   ;; accents (for iL√∂b)
   ("\\o" ?√∂)

   ;; subscripts and superscripts
   ("^^+" ?‚Å∫) ("__+" ?‚Çä) ("^^-" ?‚Åª)
   ("__0" ?‚ÇÄ) ("__1" ?‚ÇÅ) ("__2" ?‚ÇÇ) ("__3" ?‚ÇÉ) ("__4" ?‚ÇÑ)
   ("__5" ?‚ÇÖ) ("__6" ?‚ÇÜ) ("__7" ?‚Çá) ("__8" ?‚Çà) ("__9" ?‚Çâ)

   ("__a" ?‚Çê) ("__e" ?‚Çë) ("__h" ?‚Çï) ("__i" ?·µ¢) ("__k" ?‚Çñ)
   ("__l" ?‚Çó) ("__m" ?‚Çò) ("__n" ?‚Çô) ("__o" ?‚Çí) ("__p" ?‚Çö)
   ("__r" ?·µ£) ("__s" ?‚Çõ) ("__t" ?‚Çú) ("__u" ?·µ§) ("__v" ?·µ•) ("__x" ?‚Çì)
   )
  (mapc (lambda (x)
          (if (cddr x)
              (quail-defrule (cadr x) (car (cddr x)))))
  					; need to reverse since different emacs packages disagree on whether
  					; the first or last entry should take priority...
  					; see <https://mattermost.mpi-sws.org/iris/pl/46onxnb3tb8ndg8b6h1z1f7tny> for discussion
        (reverse (append math-symbol-list-basic math-symbol-list-extended)))
#+end_src

* Settings for Text Mode
Enable auto-fill.
#+begin_src emacs-lisp :results none
  (add-hook 'text-mode-hook #'auto-fill-mode)
  (setq fill-column 80)
#+end_src
Enable ~Writeroom~ mode for a more comfortable writing experience.
#+begin_src emacs-lisp :results none
  (use-package writeroom-mode)
  (add-hook 'text-mode-hook #'writeroom-mode)
  (setq writeroom-mode-line t)
  (setq writeroom-maximize-window nil)
#+end_src
Use ~aspell~ as default spell checking program (should be default, but
something is changing it)
#+begin_src emacs-lisp :results none
  (setq ispell-program-name "/usr/bin/aspell")
#+end_src
Enable ~Flyspell~ for spell checking
#+begin_src emacs-lisp :results none
  (use-package flyspell)
  (add-hook 'text-mode-hook #'flyspell-mode)
  (add-hook 'prog-mode-hook #'flyspell-prog-mode)

  (use-package flyspell-correct)
  (keymap-set flyspell-mode-map "M-$" #'flyspell-correct-wrapper)
#+end_src
Removes completion at point from ~flyspell~ so that I can use it for
completing org roam nodes.
#+begin_src emacs-lisp :results none
  (require 'flyspell)
  (keymap-unset flyspell-mode-map "C-M-i")
#+end_src
Disable word completion in text-mode
#+begin_src emacs-lisp :results none
  (setq text-mode-ispell-word-completion nil)
#+end_src
Automatic insertion of right brace in Latex-mode
#+begin_src emacs-lisp :results none
  (setq LaTeX-electric-left-right-brace t)
#+end_src

* Minibuffer completion w/Vertico

#+begin_src emacs-lisp :results none
  (use-package vertico)
  (vertico-mode 1)
  (vertico-multiform-mode 1)
#+end_src
Allows using minibuffer commands within the minibuffer.
#+begin_src emacs-lisp :results none
  (setq enable-recursive-minibuffers t)
#+end_src
TAB works the same way as in other completion systems.
#+begin_src emacs-lisp :results none
  (keymap-set vertico-map "TAB" #'minibuffer-complete)
#+end_src
Completion at point uses Vertico
#+begin_src emacs-lisp :results none
  (setq completion-in-region-function #'consult-completion-in-region)
#+end_src
Orderless allows for more flexible completion styles.
#+begin_src emacs-lisp :results none
  (use-package orderless)
  (setq completion-styles '(orderless basic))
  (setq completion-category-overrides '((file (styles partial-completion))))
  (setq completion-category-defaults nil) ;; Disable defaults, use orderless settings
  (setq completion-pcm-leading-wildcard t) ;; Emacs 31: partial-completion behaves like substring
#+end_src
More information in minibuffer
#+begin_src emacs-lisp :results none
  (use-package marginalia)
#+end_src
Icons in minibuffer
#+begin_src emacs-lisp :results none
  (use-package all-the-icons)

  (use-package all-the-icons-completion)
  (add-hook 'marginalia-mode-hook
  	  #'all-the-icons-completion-marginalia-setup)

  (all-the-icons-completion-mode)
  (marginalia-mode)
#+end_src
Vertico completion in a posframe
#+begin_src emacs-lisp :results none
  (use-package vertico-posframe)
  (vertico-posframe-mode 1)
#+end_src
Non-transparent popup
#+begin_src emacs-lisp :results none
  (setq vertico-posframe-parameters '((alpha . 100)))
#+end_src
Fixed size Vertico posframe
#+begin_src emacs-lisp :results none
  (defun my-vertico-posframe-get-size (buffer)
    "Set the vert-posframe size according to the current frame."
    (let ((height (or vertico-posframe-height 10))
          (width (min (or vertico-posframe-width 200) (round (* .9 (frame-width))))))
      (list :height height :width width :min-height height :min-width width)))

  (setq vertico-posframe-size-function #'my-vertico-posframe-get-size)
#+end_src
Do not use posframe for consult line and consult mark
#+begin_src emacs-lisp :results none
  (setq vertico-multiform-commands
        '((consult-line (:not posframe))
  	(consult-mark (:not posframe))
  	(consult-mark (:not posframe))
  	(consult-org-maybe (:not posframe))
          (t posframe)))
#+end_src
Overrides the normal find file by using the string at point as a
possible candidate
#+begin_src emacs-lisp :results none
  (global-set-key (kbd "C-x C-f") #'find-file-at-point)
#+end_src
Switch to buffer with ~recentf~ files.
#+begin_src emacs-lisp :results none
  (global-set-key (kbd "C-x b") #'consult-buffer)
#+end_src
No live preview when switching buffers
#+begin_src emacs-lisp :results none
  (setq consult-preview-excluded-buffers t)
#+end_src
Replace I-search with consult-line.  Vertico cycle is set to ~t~ so that
we can go to candidates in previous lines.
#+begin_src emacs-lisp :results none
  (setq vertico-cycle t)
  (global-set-key (kbd "C-s") #'consult-line)
#+end_src

* ~Eshell~

#+begin_src emacs-lisp :results none
  (use-package eshell)
#+end_src

Fish like suggestions for ~eshell~
#+begin_src emacs-lisp :results none
  (use-package capf-autosuggest)
  (add-hook 'eshell-mode-hook #'capf-autosuggest-mode)
#+end_src

Increase the history size.  This is helpful when using ~capf-autosuggest~
since that package checks the history for completion candidates.
#+begin_src emacs-lisp :results none
  (setq eshell-history-size 50000)
#+end_src
Pretty ~eshell~ prompt
#+begin_src emacs-lisp :results none
  (load-file "/home/tiago/.config/prompt.el")
  (setq eshell-prompt-function #'epe-theme-dakrone)
#+end_src
Function for clearing the shell
#+begin_src emacs-lisp :results none
  (defun eshell-clear ()
    (interactive)
    "Clear the eshell buffer."
    (let ((inhibit-read-only t))
      (erase-buffer)
      (eshell-send-input)
      (beginning-of-buffer)
      (kill-line)
      (end-of-buffer)
      ))
#+end_src
Function for getting to the base of any project. Useful for spawning
shells since having it at the root of the project is generally more
convenient.
#+begin_src emacs-lisp :results none
  (defvar project-files
    '("dune-project" "package.json"
      "CoqProject" "Makefile"
      )
    )

  (defun is-base ()
    (or (equal default-directory "/")
        (not (eq (seq-intersection
           (directory-files ".")
           project-files
           'equal
           ) nil)
        ))
    )

  (defun get-to-base ()
    (let ((c default-directory))
    (progn
      (while (not (is-base))
        (find-file ".."))
      (when (equal default-directory "/")
          (find-file c)
          )
    )))
#+end_src
Always spawns eshell on a new terminal
#+begin_src emacs-lisp :results none
  (defun multi-eshell ()
    (interactive)
    (let ((b (current-buffer)))
    (when (seq-find
           (lambda (val)
             (equal "*eshell*" (buffer-name val)))
           (buffer-list))
      (switch-to-buffer "*eshell*")
      (rename-uniquely))
    (switch-to-buffer b)
    (eshell)))
#+end_src
Key binding for spawning a new instance of ~eshell~ at the root of a
project.

#+begin_src emacs-lisp :results none
  (defun eshell-spawn ()
    (interactive)
    (get-to-base)
    (multi-eshell))
  (bind-key "C-c C-SPC" 'eshell-spawn)
#+end_src
Delete duplicates in the ~eshell~ history
#+begin_src emacs-lisp :results none
  (setq eshell-hist-ignoredups t)
#+end_src
Augments ~eshell~'s completion framework so that it behaves more like
fish (e.g. "pacman -S ..." completes the name of the package)
#+begin_src emacs-lisp :results none
  (use-package fish-completion)
  (global-fish-completion-mode 1)
#+end_src
I never know man
#+begin_src emacs-lisp :results none
  (setq eshell-cmpl-dir-ignore "\\`\\(CVS\\)/\\'")
#+end_src
Add rust packages to path
#+begin_src emacs-lisp :results none
  (add-to-list 'exec-path "~/.cargo/bin")
#+end_src

Buffer name matches eshell directory
#+begin_src emacs-lisp :results none
  (defun sync-dir-in-buffer-name ()
    (rename-buffer (concat "*eshell* " default-directory) t))

  (add-hook 'eshell-mode-hook #'sync-dir-in-buffer-name)
  (add-hook 'eshell-directory-change-hook #'sync-dir-in-buffer-name)
#+end_src
No message when starting ~eshell~
#+begin_src emacs-lisp :results none
  (setq eshell-banner-message "")
#+end_src
Keybinding to clear the shell
#+begin_src emacs-lisp :results none
  (keymap-set eshell-mode-map "C-l" #'eshell-clear)
#+end_src
We use eat to run any commands that require visuals
#+begin_src emacs-lisp :results none
  (use-package eat)
  (setq eat-kill-buffer-on-exit t)
  (add-hook 'eshell-mode-hook #'eat-eshell-mode)
#+end_src

* Gospel Specific Things
Some macros to help writing Rocq proofs of Gospel signatures.
#+begin_src emacs-lisp :results none
  (defun gospel-abstract (var)
    (interactive "sName:")
    (insert
     (format
      "Global Instance _%s_inst : _%s_sig :="
      var var))
    (newline 1 t)
    (insert (format "{ %s :=  }." var))
    (backward-char 3))

  (defun gospel-lemma (var)
    (interactive "sName:")
    (insert
     (format
      "#[refine] Global Instance _%s_inst : _%s_sig := { }."
      var var var))
    (newline 1 t)
    (insert "Proof.")
    (newline 1 t))
#+end_src
Function to insert Gospel header
#+begin_src emacs-lisp :results none
(defun gospel-header ()
      (interactive)
      (insert "(**************************************************************************)
(*                                                                        *)
(*  GOSPEL -- A Specification Language for OCaml                          *)
(*                                                                        *)
(*  Copyright (c) 2018- The VOCaL Project                                 *)
(*                                                                        *)
(*  This software is free software, distributed under the MIT license     *)
(*  (as described in file LICENSE enclosed).                              *)
(**************************************************************************)
  "))
#+end_src
Add the preamble necessary to write math symbols in a latex Gospel
code block.
#+begin_src emacs-lisp :results none
  (defun gospel-unicode () (interactive) (tag-word-or-region "*?$" "$?*"))
  (require 'latex)
  (keymap-set LaTeX-mode-map "C-c C-x C-m" #'gospel-unicode)
#+end_src
